# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Адамов А. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки – основная структура данных, применяемая в языке Пролог, они являются основой для организации всех сложных вычислений. Одно из основных свойств списка – отсутствие ограничений на элементы и размер списка. Вложенность списков также ничем не ограничивается. Список в языке трактуется как структура из двух элементов – «головы» и «хвоста». Это разделение является основой вычислений над списками. От принятых в императивных языках подходов к хранению данных списки Пролога отличаются, в первую очередь, произвольным типом элементов, такое свободное отношение к типам редко в императивных языках. Списки Пролога очень похожи на бинарные деревья, с тем допущением, что каждый узел имеет лист.

## Задание 1.1: Предикат обработки списка

`remove_last([X|T],[X|T2])` - удаление последнего элемента списка

Примеры использования:
```prolog
?- remove_last([a, b, c], L).
L = [a, b]
```

Реализация:
```prolog
remove_last([_],[]).
remove_last([X|T],[X|T2]) :- remove_last(T, T2).
```

Предикат возвращает список с усеченным концом.

## Задание 1.2: Предикат обработки числового списка

`issorted([X,Y|Z])` - проверка отсортированности массива

Пример:
```prolog
?- issorted([1,2,3]).
true .

?- issorted([1,5,3]).
false.
```

Реализация:
```prolog
issorted([]).
issorted([_]).
issorted([X,Y|Z]) :- X=<Y, issorted([Y|Z]).
```

Предикат проходит рекурсивно по списку, сравнивая два соседних элемента.

## Задание 2: Реляционное представление данных

Мое представление позволяет сразу получать значения оценок для всех студентов и для каждого предмета. Однако, просмотр личной характеристики каждого студента не очень удобен. С помощью данного представления можно найти оценки по конкретным предментам и по группам.

Вариант 1
- Получить таблицу групп и средний балл по каждой из групп
```prolog
group(X,L) :- bagof([N,C,M],grade(X,N,C,M),L).
avg_mark(X, Y) :- findall(M,grade(X,N,C,M),L1), sum(L1,0,S), mylen(L1,L), Y is S/L.
```
Пример:
```prolog
?- group(102, L).
L = [['Петров', 'Логическое программирование', 4], ['Петров', 'Математический анализ', 2], ['Пет
ров', 'Функциональное программирование', 3], ['Петров', 'Информатика', 5], ['Петров', 'Английски
й язык', 5], ['Петров', 'Психология', 4], ['Ивановский', 'Логическое программирование'|...], ['И
вановский'|...], [...|...]|...].

?- avg_mark(102, Y).
Y = 3.7037037037037037.
```

- Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
```prolog
notpassed(C,L) :- findall([X,N],grade(X,N,C,2),L).
```
Пример:
```prolog
?- notpassed('Информатика', L).
L = [[103, 'Сиплюсплюсов'], [102, 'Текстописов']].
```

- Найти количество не сдавших студентов в каждой из групп
```prolog
count_notpassed(X, Num):-findall(2, grade(X,N,C,2), Marks), mylen(Marks, Num).
```
Пример:
```prolog
?- count_notpassed(102,Num).
Num = 5.
```

## Выводы

Лабораторная работа познакомила с основными методами работы со списками на прологе. Читать программы на прологе несложно, так как в языке очень мало специальных символов и ключевых слов и они легко переводятся на естественный язык. Думаю, трудности с ним могут возникнуть только при попытке сразу представить как работает программа, а не прочитать, что она описывает.
